#!/usr/bin/env python

import optparse, re, os

#Designed to split a single cluster generated by clusterProts.py into multiple clusters, based on gene name annotations

def main():
    usage = '%prog [options]'
    p = optparse.OptionParser()
    p.add_option('-c', '--clust',  help='Starting cluster fasta. [None, REQ]')
    p.add_option('-g', '--genes',  help='Fasta file with gene annotation info. [None, REQ]')
    p.add_option('-i', '--info',  help='File with info for output files. One line per output file. Each line should have two tab-delimited columns: 1) output name and 2) comma-separated list of gene names to include [None, REQ]')
    opts, args = p.parse_args()
    
    #Get gene names from a fasta file that contains this info in the seq names
    id2info = extractGeneAnnotInfo(opts.genes)
    
    #Read in starting fasta file
    names, seqs = read_fasta_lists(opts.clust)
    
    #Get gene names for each seq
    gs = []
    for n in names:
        idpat = re.compile("ID=(\w+_\w+)")
        match = idpat.search(n)
        if match:
            gs.append(id2info[match.group(1)])
        else:
            gs.append("")
    
    
    #Step through output clusters
    with open(opts.info, "r") as fin:
        for line in fin:
            outN = []
            outS = []
            outname, genenames = line.rstrip("\n").split("\t")
            genenames = genenames.split(",")
            for i in range(len(names)):
                if gs[i] in genenames:
                    outN.append(names[i])
                    outS.append(seqs[i])
            write_fasta(outN, outS, outname)
            

#----------------------End of main()

def extractGeneAnnotInfo(file):
    id2info={}
    refNames, refSeqs = read_fasta_lists(file)
    for n in refNames:
        idpat = re.compile("ID=(\w+_\w+)")
        ID = idpat.search(n)
        try:
            DE = n.split(" DE=")[1].split(" GN=")[0].split(" OXX=")[0].split(" Full=")[1].split(";")[0].split("{")[0].strip()
            id2info[ID.group(1)] = DE
        except:
            print("Not able to extract info from %s" % n)
    return(id2info)


# Extracts data from a fasta sequence file. Returns two lists, the first holds the names of the seqs (excluding the '>' symbol), and the second holds the sequences
def read_fasta_lists(file):
    fin = open(file, 'r')
    count=0
    
    names=[]
    seqs=[]
    seq=''
    for line in fin:
        line=line.strip()
        if line and line[0] == '>':                #indicates the name of the sequence
            count+=1
            names.append(line[1:])
            if count>1:
                seqs.append(seq)
            seq=''
        else: seq +=line
    seqs.append(seq)
    
    return names, seqs

#writes a new fasta file
def write_fasta(names, seqs, new_filename):
    fout=open(new_filename, 'w')
    for i in range(len(names)):
        fout.write(">%s\n%s\n" % (names[i], seqs[i]))
    fout.close()

###------------------------------------->>>>    

if __name__ == "__main__":
    main()

