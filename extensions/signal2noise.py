#!/usr/bin/env python

import matplotlib.pyplot as plt
import matplotlib as mpl
mpl.rcParams['pdf.fonttype'] = 42

import optparse
import numpy as np
import statistics as stat

# The goal of this script is to plot bin-level differences in norm counts for enriched peptides vs. background, in order to estimate relative levels of signal-to-noise across samples and runs

colors = ['#8dd3c7','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69','#fccde5','#d9d9d9','#bc80bd','#ffffb3']

def main():
    usage = '%prog [options]'
    p = optparse.OptionParser()
    p.add_option('-i', '--input',  help='Tab-delimited input file, with one row per input matrix. The first column should contain a simple string to be used in output to refer to this file. The second column should be a score matrix that will be used to make plots [None, REQ]')
    p.add_option('-b', '--bins',  help='Bin file, in the format generated by the PepSIRF bin module. [None, REQ]')
    p.add_option('-u', '--upper', type="int", help="Upper percentile to use to calculate average value for 'signal'. Must be between 0 and 100, inclusive. [None, REQ]")
    p.add_option('-l', '--lower', type="int", help="Lower percentile to use to calculate average value for 'noise'. Must be between 0 and 100, inclusive. [None, REQ]")
    p.add_option('-o', '--out', help='Base name for output files. [None, REQ]')
    p.add_option('--fig', default="png", help="Figure format to output.")
    p.add_option('--width', default=15, type=int, help="Figure width.")
    p.add_option('--height', default=4, type=int, help="Figure height.")

#    p.add_option('--hpd', type="float", help="Highest posterior density to use for calculation of mean and standard deviation. Must be between 0 and 1. [None, REQ]")

    opts, args = p.parse_args()
    
    # Read in bins
    bins = readGroups(opts.bins)
    
    # Open figure 
    fig,ax = plt.subplots(1,1,figsize=(opts.width, opts.height),facecolor='w')

    
    # Open output file for writing
    with open("%s.tsv" % (opts.out), "w") as fout:
        #Write header for output file
        fout.write("Sample\tFile\tBin\tUpper%d\tLower%d\tDifference\n" % (opts.upper, opts.lower))
        
        #Step through each score matrix file
        matCount=-1
        with open(opts.input, "r") as fin:
            for line in fin:
                matCount+=1
                fileStr,fileLoc = line.rstrip("\n").split("\t")
                
                # Read in matrix
                sD = parseCounts(fileLoc)
                
                
                for samp, cD in sD.items():

                    # Create list to collect all bin diffs
                    diffL = []

                    for i, g in enumerate(bins):
                        counts=[cD[each] for each in g]
                        lo,hi = np.percentile(counts, [opts.lower, opts.upper])
#                        lo,hi=get_hpd(counts,opts.hpd)

                        upperVals = [x for x in counts if x>=hi]
                        lowerVals = [x for x in counts if x<=lo]
        
                        upAvg = np.mean(upperVals)
                        loAvg = np.mean(lowerVals)
                        
                        diff = upAvg-loAvg
                        diffL.append(diff)
                        
                        fout.write("%s\t%s\t%d\t%.5f\t%.5f\t%.5f\n" % (samp, fileStr, i, upAvg, loAvg, diff))
                
                    # Add line to plot
                    ax.plot(list(range(len(diffL))), diffL, c=colors[matCount], label=fileStr, alpha=0.5)
        
        fig.legend()
        fig.savefig("%s.%s" % (opts.out, opts.fig),dpi=300,bbox_inches='tight')

#----------------------End of main()


def readGroups(file):
    g=[]
    with open(file, "r") as fin:
        for line in fin:
            cols=line.rstrip("\n").split("\t")
            if cols:
                g.append(cols)
    return g


def writeCounts(cd, outname):
    probeNames = sorted(cd[list(cd.keys())[0]].keys())
    sampNames =  sorted(list(cd.keys()))
    with open(outname, "w") as fout:
        fout.write("Probe\t%s\n" % ("\t".join(sampNames)))
        for each in probeNames:
            fout.write("%s\t%s\n" % (each, "\t".join([str(cd[x][each]) for x in sampNames])))


def parseCounts(countFile, delim="\t"):
    counts={}
    with open(countFile, "r") as fin:
        lc=0
        for line in fin:
            lc+=1
            cols=line.rstrip("\n").split(delim)
            if lc == 1:
                names = cols[1:]
                for n in names:
                    counts[n]={}
            else:
                for i, count in enumerate(cols[1:]):
                    counts[names[i]][cols[0]] = float(count)
    return counts


def get_hpd(data, level):
    """
    Return highest posterior density interval from a list,
    given the percent posterior density interval required.
    """
    d = list(data)
    d.sort()

    nData = len(data)
    nIn = int(round(level * nData))
    if nIn < 2 :
        return None
   #raise RuntimeError("Not enough data. N data: %s"%(len(data)))
 
    i = 0
    r = d[i+nIn-1] - d[i]
    for k in range(len(d) - (nIn - 1)) :
        rk = d[k+nIn-1] - d[k]
        if rk < r :
            r = rk
            i = k

    assert 0 <= i <= i+nIn-1 < len(d)
 
    return (d[i], d[i+nIn-1])


###------------------------------------->>>>    

if __name__ == "__main__":
    main()

